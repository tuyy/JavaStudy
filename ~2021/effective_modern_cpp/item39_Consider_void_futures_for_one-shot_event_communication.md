어떤 특정한 사건(event)이 일어나야만 작업을 진행할 수 있는 비동기 실행 과제에게 그 사건이 발생했음을 알려주는 또 다른 과제를 두는 것이 유용한 경우가 있다.
어떤 종류의 사건이든, 이러한 스레드 간 통신을 처리하는 가장 나은 방법은 무엇일까?

한 가지 명백한 접근방식은 조건 변수(condition variable)을 사용하는 것이다.

조건을 검출하는 과제를 검출 과제(detecting task)라 하고,
그 조건에 반응하는 과제를 반응 과제(reaction task)라 부르기로할 때,

std::contition_variable cv;  // 사건을 위한 조건 변수
std::mutex m;  // cv와 함께 사용할 뮤텍스

검출 과제 코드
…  // 사건을 검출한다.
cv.notify_one();  // 반응 과제에게 알린다. (만약 사건 발생을 알려줄 반응 과제가 여러 개라면 notify_all을 사용하는 것이 적합)

반응 과제 코드
… // 반응 준비
{
    std::unique_lock<std::mutex> lk(m);  // 뮤텍스를 잠근다.
    cv.wait(lk);  // 통지를 기다린다. 제대로 된 방식은 아님!
} // 임계 영역을 닫는다. lk의 소멸자가 m을 해제한다.
…

이 예에서 코드냄새의 근원은 뮤텍스가 필요하다는 점이다.

추가로,
1) 만일 반응 과제가 wait를 실행하기 전에 검출 과제가 조건 변수를 통지하면 반응 과제가 멈추게 된다.(hang)
2) wait 호출문은 가짜 기상을 고려하지 않는다.  // 조건 변수가 통지되지 않았는데도 깨어날 수 있음

가짜 기상 문제를 해결하는 방법으로, wait()에서 깨어난 후 정말 해당 과제가 발생한건지 확인 하면된다.

cv.wait(lk, []{ return 사건 발생 여부; });

물론, 그러한 방식은 검출 과제가 아주 기묘한 방식으로 반응 과제와 통신한다는 점이 좀 꺼림칙하다.
(뮤텍스, 부울 플래그 등 사용..)

조건 변수와 뮤텍스, 플래그를 아예 사용할 필요가 없는 한 가지 대안은, 검출 과제가 설정한 미래 객체를 반응 과제가 기다리게(wait를 통해서) 하는 것이다.

std::promise<void> p;

검출과제
.. // 사건 검출
p.set_value();

반응과제
…  // 반응 준비
p.get_future().wait();  // p에 해당하는 미래 객체를 기다린다.
// 사건에 반응한다.

위에는 많은 장점이 있지만, 한가지 단점이 있다.
std::promise와 미래 객체 사이에는 공유 상태가 있으며, 대체로 공유 상태는 동적으로 할당된다. 따라서 이 설계는 힙 기반 할당 및 해제 비용을 유발한다고 가정해야한다. 또한 std::promise를 한 번만 설정할 수 있다는 점도 중요하다.

std::promise<void> p;

void detect() {
    auto sf = p.get_future().share();
    std::vector<std::thread> vt;

    for (int i = 0;i < threadsToRun; ++i) {
        vt.emplace_back([sf]{ sf.wait(); react(); });  // sf의 지역 복사본을 기다린다.
    }
}
…  // 만일 이 부분에서 예외가 발생한다면, 프로그램은 종료된다.

p.set_value();  // 모든 스레드의 유보를 푼다.

…

for (auto &t : vt) {
    t.join();
}


기억해 둘 사항들
1) 간단한 사건 통신을 수행할 때, 조건 변수 기반 설계에는 여분의 뮤텍스가 필요하고, 검출 과제와 반응 과제의 진행 순서에 제약이 있으며, 사건이 실제로 발생했는지를 반응 과제가 다시 확인해야 한다.
2) 플래그 기반 설계를 사용하면 그런 단점들이 없지만, 대신 차단이 아니라 폴링이 일어난다는 단점이 있다.
3) 조건 변수와 플래그를 조합할 수도 있으나, 그런 조합을 이용한 통신 매커니즘은 필요 이상으로 복잡하다.
4) std::promise와 미래 객체를 사용하면 이러한 문제점들을 피할 수 있지만, 그런 접근방식은 공유 상태에 힙 메모리를 사용하며, 단발성 통신만 가능하다.
