std::atomic 객체가 성공적으로 생성되고 나면, 그 객체에 대한 연산은 마치 뮤텍스로 보호되는 임계영역 안에서 수행되는 것처럼 동작한다.

std::atomic<int> ai(0);
ai = 10;
std::cout << ai;
++ai;
—ai;

위 문장에서 원자적인 부분은 오직 ai를 읽는 부분이다.

1.
std::atomic 객체가 생성되고 나면 증가나 감소 연산은 읽기-수정-쓰기(read-modify-write, RMW) 연산이지만, 각각 원자적으로 수행된다.
반면 volatile int vi(0);  연산은 다중 스레드 문맥에서 거의 아무것도 보장하지 않는다.

예를 들면,

/*—— thread 1 ——*/    /*—— thread 2—-*/
          ++ac;                              ++ac;
          ++vc;                              ++vc;
(ac는 std::atomic, vc는 volitile)

1) 스레드 1이 vc의 값을 읽는다. 값은 0이다.
2) 스레드 2가 vc의 값을 읽는다. 값은 여전히 0이다.
3) 스레드 1이 자신이 읽은 값 0을 증가하고, 그 결과인 1을 vc에 기록한다.
4) 스레드 2가 자신이 읽은 값 0을 증가하고, 그 결과인 1을 vc에 기록한다.

결과적으로, vc의 최종 값은 예측할 수 없다.

2.
std::atomic<bool> valAvailable(false);
auto imptValue = computeImportantValue();
valAvailable = true;

위 코드는 std::atomic이 아니었다면, 배정 순서가 컴파일러나 하드웨어에 따라 뒤 바뀔 수 있다.
하지만 std::atomic을 사용하면, 코드의 순서 재배치에 대한 제약들이 생기게 되어 관련 문제에서 벗어 날 수 있다.
그러나 volitile은 이런 제약이 생기지 않아, 코드의 순서가 바뀔 수 있다!



명확한 사용처
std::atomic은 동시적 프로그래밍에 유용하나, 특별한 메모리의 접근에는 유용하지 않다.
volatile은 특별하 메모리의 접근에 유용하나, 동시적 프로그래밍에는 유용하지 않다. (이 메모리에 대한 연산들에는 그 어떤 최적화도 수행하지 말라고 지시하는 격)

기억해 둘 사항들
1) std::atomic은 뮤텍스 보호 없이 여러 스레드가 접근하는 자료를 위한 것으로, 동시적 소프트웨어의 작성을 위한 도구이다.
2) volatile은 읽기와 기록을 최적화로 제거하지 말아야 하는 메모리를 위한 것으로, 특별한 메모리를 다룰 때 필요한 도구이다.
