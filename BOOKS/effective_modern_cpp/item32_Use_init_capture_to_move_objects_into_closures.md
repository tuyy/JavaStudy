이동 전용 객체(std::unique_ptr, std::future 등)를 클로저 안으로 들여오려는 경우 값 갈무리, 참조 갈무리도 마땅치 않은 경우가 있다.

이동 전용 객체를 클로저 안으로 들여오려는 경우가 좋은 예인데, C++11에는 그렇게 할 방법이 없다.

또한 복사는 비싸고 이동은 저렴한 객체를 클로저 아으로 들여온다면 복사보다는 이동이 적용되게 하는것이 바람직한데, 역시나 C++11에는 그렇게 할 방법이 없다.

하지만 C++14에는 초기화 갈무리(init capture)라는 것을 지원한다.

초기화 갈무리로는 다음과 같은 것들을 지정할 수 있다.
1) 람다로부터 생성되는 클로저 클래스에 속한 자료 멤버의 이름
2) 그 자료 멤버를 초기화하는 표현식

class Widget {};

auto pw = std::make_unique<Widget>();
…
// 클로저의 자료 멤버를 std::move로 초기화한다. 이 시점에 std::move 연산이 동작한다.
auto func = [pw = std::move(pw)] { return pw->isValidated() };

좌변은 해당 클로저 클래스의 범위이고, 우변의 범위는 람다가 정의되는 지점의 범위와 동일하다.

// 직접 초기화도 가능하다.
auto func = [pw = std::unique_ptr<Widget>()] { return pw->isValidated() };

C++11에서는 어떤 표현식의 결과를 갈무리하는 것이 불가능했지만, 이 예에서 보듯이 C++14에서는 가능하다.


다행히도 C++11에도 이동 갈무리를 흉내 내는 방법이 있다. (직접 클래스 생성, std::bind() 사용)
1) 갈무리할 객체를 std::bind가 산출하는 함수 객체로 이동하고,
2) 그 ‘갈무리된’ 객체에 대한 참조를 람다에 넘겨준다.

std::vector<double> data;
…
auto func =
    std::bind(  // C++11에서 초기화 갈무리를 흉내 내는 방법
        [](const std::vector<double> &data)  // 인자로 사용
        { /* data를 사용 */},
        std::move(data)
    );

기억해 둘 사항들
1) 객체를 클로저 안으로 이동할 때에는 C++14의 초기화 갈무리를 사용하라.
2) C++11에서는 직접 작성한 클래스나 std::bind로 초기화 갈무리를 흉내 낼 수 있다.
