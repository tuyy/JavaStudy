std::thread 와 std::future 객체 모두 시스템 스레드에 대한 핸들이라고 할 수 있다.

std::thread와 std::future 소멸자 관련 비교
1) joinable한 std::thread의 소멸자가 호출되면 프로그램은 종료된다.
2) std::future 객체의 소멸자는 어떨때는 암묵적 join or 암묵적 detach를 수행한 것 같은 결과를 낸다.

std::future 객체의 응답 결과는 어디에 저장될까?
바로 공유 상태(shared state)에 저장 된다. 일반적으로 공유 상태는 힙 기반 객체로 표현되나 그 형식과 인터페이스 구현은 표준이 구체적으로 명시하지 않는다.

이 공유 상태의 존재가 중요한 것은, std::future 객체 소멸자의 행동을 그 객체와 연관된 공유 상태가 결정하기 때문이다.

1) std::async를 통해서 시동된 비지연 과제에 대한 공유 상태를 참조하는 마지막 미래 객체의 소멸자는 과제가 완료될 때까지 차단된다. (암묵적 join 수행)
2) 다른 모든 미래 객체의 소멸자는 그냥 해당 미래 객체를 파괴한다. (암묵적 detach)

소멸자는 미래 객체와 피호출자의 std::promise가 함께 참조하는 공유 상태 안의 참조 횟수를 감소한다.

이 정상 행동에 대한 예외는 다음 조건들을 모두 만족하는 미래 객체에 대해서만 일어난다.

1) 미래 객체가 std::aync 호출에 의해 생성된 공유 상태를 참조한다.
2) 과제의 시동 방침이 std::launch::async이다. (시스템이 선택한 경우와 명시적으로 지정한 경우 모두 포함)
3) 미래 객체가 공유 상태를 참조하는 마지막 미래 객체이다.

실용적인 관점에서 말하자면, 이는 std::async로 생성한 과제를 실행하는 스레드에 대해 암묵적 join을 호출하는 것에 해당한다.

미래 객체에 대한 API는 주어진 미래 객체가 std::async 호출에 의해 생긴 공유 상태를 참조하는지를 판단할 수 있는 수단을 제공하지 않으므로,
임의의 미래 객체에 대해 그 소멸자가 비동기적으로 실행되는 과제의 완료를 기다리느라 차단될 것인지를 알아내는 것은 불가능하다.

// 이 컨테이너는 소멸자에서 차단될 수 도 있다.
// 컨테이너에 담긴 하나 이상의 미래 객체들이 std::async를 통해 시동된 비지연 과제에 대한 공유 상태를 참조할 수도 있기 때문이다.
std::vector<std::future<void>> futs;

class Widget {
public:
…
private:
    std::shared_future<double> fut;
};


std::async 호출에서 비롯된 경우에만 소멸자의 특별 행동이 일어날 수 있다. 그러나 그 외의 여러 원인으로도 공유 상태가 생성될 수 있다.

std::packaged_task 객체는 주어진 함수를 비동기적으로 실행할 수 있도록 포장하는데, 포장된 함수의 실행 결과는 공유 상태에 저장된다.

int calc();

std::packaged_task<int()> pt(calcValue);

auto fut = pt.get_future();  // std::async 호출로 만들어진 공유 상태를 참조하지 않음이 명확하므로 해당 소멸자는 정상적으로 행동한다.
성공적으로 생성한 std::packaged_task 객체는 임의의 스레드에서 실행할 수 있다. std::async 호출을 통해서 실행할 수도 있다.
 
하지만 그것은 std::packaged_task 객체를 생성할 이유가 되지 못한다. 어차피 std::async가 과제의 실행 일정을 결정하기 전에 수행하는 작업에는std::packaged_task가 수행하는 모든 것이 포함되기 때문이다.

std::packaged_task<int()> pt(calc);
auto fut = pt.get_future();
std::thread t(std::move(pt));  // pt를 스레드 t에서 실행

결과적으로, 이렇게 하면 소멸자의 특별한 행동을 고려한 코드를 작성할 필요가 없다. 종료와 합류, 탈착에 대한 결정은 이미 해당 std::thread를 조작하는 코드에서 내려지기 때문이다.


기억해 둘 사항들
1) 미래 객체의 소멸자는 그냥 미래 객체의 자료 멤버들을 파괴할 뿐이다.
2) std::async를 통해 시동된 비지연 과제에 대한 공유 상태를 참조하는 마지막 미래 객체의 소멸자는 그 과제가 완료될 때까지 차단된다.
