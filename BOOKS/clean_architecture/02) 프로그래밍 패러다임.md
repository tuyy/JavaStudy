## 프로그래밍 패러다임
* 패러다임은 프로그래밍을 하는 방법으로 언어에 독립적이다.
* 패러다임은 프로그래머에게서 권한을 박탈함으로서 존재한다.
    * 무엇을 해야 할지 보다 무엇을 해서는 안되는지를 말해준다.
    * 1958 ~ 1968 10년 동안 모두 만들어짐.. 더 이상의 추가적인 패러다임은 없을 것이다.
* 구조적 프로그래밍, 객체지향 프로그래밍, 함수형 프로그래밍이 있다.

### 구조적 프로그래밍
* 직접적인 goto문을 제거하고 if/then/else, do/while/until 등과 같이 익숙한 구조로 대체하였다.
* 오늘 날 모든 프로그래밍 언어는 구조적 프로그래밍에 기반한다.
* 제어흐름의 직접적인 전환에 대한 규칙을 부과한다.
* 구조적 프로그래밍이 오늘날까지 가치있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있게하기 때문이다.
* 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트가 쉽도록) 만들기 위해 노력해야한다.

### 객체 지향 프로그래밍 (OOP)
* 제어흐름의 간접적인 전환에 대한 규칙을 부과함
* C에는 캡슐화, 상속, 다형성가 없지 않나? No!
    * 엄밀히 말하면 C에서 더 제대로된 캡슐화를 통한 데이터 은닉을 제공했다.
    * 상속이 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일을 말한다면 기존 C에서도 구현가능했다.
    * 다형성 또한 C에서 void*를 통해 제공했다.
    * 결과적으로, OO 언어가 새롭게 제공하는 기능은 없다. 그러나 언어적으로 다형성/상속/캡슐화를 지원하면서 좀 더 안전하고 실수를 방지할 수 있게 하였다.
* 아키텍처 관점에서 다형성은 정말 중요하다.
    * 어디서든 쉽게 플러그인아키텍처를 만들 수 있게 한다.
    * 저수준 세부사항이 고수준 함수를 의존하게 할 수 있다. (의존성 역전)
* 소프트웨어아키텍트 관점에서의 객체지향이란?
    * 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
    * OO를 사용하면 아키텍트 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.
    * 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.

### 함수형 프로그래밍
* 이 패러다임에서 핵심이 되는 기반은 기존 람다 계산법으로 1930년대에 개발했다.
* 할당문에 대한 규칙을 부과한다.
* 현명한 아키텍트라면 가능한 많은 처리를 불변 컴포넌트로 옮겨야한다.
    * 경합조건, 교착상태, 동시 업데이트 문제가 모두 가변 변수로 인해 발생하기 때문이다.
* 이벤트소싱: 상태가 아닌 트랜잭션을 저장하자는 전략이다.
